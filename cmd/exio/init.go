package main

import (
	"bufio"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"
)

// Config represents the Exio client configuration file.
type Config struct {
	Server    string `yaml:"server"`
	Token     string `yaml:"token"`
	Subdomain string `yaml:"subdomain,omitempty"`
}

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize Exio configuration",
	Long: `Interactive setup wizard to configure Exio.

This command will prompt you for:
- Server URL (your Exio server endpoint)
- Authentication token
- Default subdomain (optional)

Configuration is saved to ~/.exio.yaml`,
	RunE: runInit,
}

func init() {
	rootCmd.AddCommand(initCmd)
}

func runInit(cmd *cobra.Command, args []string) error {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println()
	fmt.Println("  ╭───────────────────────────────────╮")
	fmt.Println("  │       Welcome to Exio!            │")
	fmt.Println("  │   Let's configure your client     │")
	fmt.Println("  ╰───────────────────────────────────╯")
	fmt.Println()

	// Check for existing config
	configPath := getConfigPath()
	if _, err := os.Stat(configPath); err == nil {
		fmt.Printf("Existing configuration found at %s\n", configPath)
		fmt.Print("Overwrite? [y/N]: ")
		response, _ := reader.ReadString('\n')
		response = strings.TrimSpace(strings.ToLower(response))
		if response != "y" && response != "yes" {
			fmt.Println("Aborted.")
			return nil
		}
		fmt.Println()
	}

	config := &Config{}

	// Server URL
	fmt.Print("Server URL (e.g., https://tunnel.example.com): ")
	serverURL, _ := reader.ReadString('\n')
	serverURL = strings.TrimSpace(serverURL)

	if serverURL == "" {
		return fmt.Errorf("server URL is required")
	}

	// Validate URL format
	parsedURL, err := url.Parse(serverURL)
	if err != nil || (parsedURL.Scheme != "http" && parsedURL.Scheme != "https") {
		return fmt.Errorf("invalid server URL: must be http:// or https://")
	}
	config.Server = serverURL

	// Auth token
	fmt.Print("Auth token: ")
	token, _ := reader.ReadString('\n')
	token = strings.TrimSpace(token)

	if token == "" {
		return fmt.Errorf("auth token is required")
	}
	config.Token = token

	// Default subdomain (optional)
	fmt.Print("Default subdomain (leave blank for random): ")
	subdomain, _ := reader.ReadString('\n')
	subdomain = strings.TrimSpace(subdomain)
	config.Subdomain = subdomain

	fmt.Println()

	// Test connection
	fmt.Print("Testing connection... ")
	if err := testConnection(config); err != nil {
		fmt.Println("FAILED")
		fmt.Printf("\nConnection test failed: %v\n", err)
		fmt.Print("\nSave configuration anyway? [y/N]: ")
		response, _ := reader.ReadString('\n')
		response = strings.TrimSpace(strings.ToLower(response))
		if response != "y" && response != "yes" {
			fmt.Println("Aborted.")
			return nil
		}
	} else {
		fmt.Println("OK")
	}

	// Save configuration
	if err := saveConfig(config, configPath); err != nil {
		return fmt.Errorf("failed to save config: %w", err)
	}

	fmt.Println()
	fmt.Printf("Configuration saved to %s\n", configPath)
	fmt.Println()
	fmt.Println("You can now run:")
	fmt.Println("  exio http 3000         # Expose port 3000")
	if config.Subdomain != "" {
		fmt.Printf("  (using subdomain: %s)\n", config.Subdomain)
	}
	fmt.Println()

	return nil
}

func getConfigPath() string {
	home, err := os.UserHomeDir()
	if err != nil {
		return ".exio.yaml"
	}
	return filepath.Join(home, ".exio.yaml")
}

func testConnection(config *Config) error {
	// Create a simple HTTP request to check if the server is reachable
	client := &http.Client{
		Timeout: 10 * time.Second,
	}

	// Try to reach the server (just check if it responds)
	req, err := http.NewRequest("GET", config.Server, nil)
	if err != nil {
		return fmt.Errorf("invalid server URL: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+config.Token)

	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("cannot reach server: %w", err)
	}
	defer resp.Body.Close()

	// Any response (even 404) means the server is reachable
	// 401 means bad token but server is reachable
	if resp.StatusCode == http.StatusUnauthorized {
		return fmt.Errorf("authentication failed (invalid token)")
	}

	return nil
}

func saveConfig(config *Config, path string) error {
	data, err := yaml.Marshal(config)
	if err != nil {
		return err
	}

	// Add header comment
	content := "# Exio client configuration\n# Generated by 'exio init'\n\n" + string(data)

	return os.WriteFile(path, []byte(content), 0600)
}
